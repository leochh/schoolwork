#+TOC: nil
* Algorithm Description
** Bisection method
   The bisection method in mathematics is a root-finding method that repeatedly
   bisects an interval and then selects a subinterval in which a subinterval
   in which a root must lie for further processing.
** Newton-Raphson method
   The Newton-Raphson method is a method for finding successively better
   approximations to the roots of a real-valued function. The formula of
   Newton-Raphson method: \[x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}\]

* Proof
** Bisection method
   Assume the given number X_0 is positive. Because the symmetry of the positive
   and negative number on number axis, this algorithm should work for
   negative number if it works for positive number.

   a. If x_0 > 1, let $x_{high_0}$ = x_0, $x_{low_0}$ = 0, $x_{mid_0} = \frac{x_{high_0} + x_{low_0}}{2}$
   #+begin_src python :exports results :results file
   import matplotlib.pyplot as plt
   import numpy as np

   fig = plt.figure()
   ax = fig.add_subplot(111)

   a = [0,1,1.75,1.912931,2.625,3.5,7]
   plt.hlines(0,0,10)
   plt.ylim(-1,1)
   y = np.zeros(np.shape(a))
   plt.plot(a,y,'.',ms=6)
   ax.text(0,-0.1,r'0')
   ax.text(1,-0.1,r'1')
   ax.annotate(r'$x_{mid_1}$',xy=(1.75,0.01),xytext=(1.75,0.15),
               arrowprops=dict(arrowstyle="->"))
   ax.annotate(r'$\sqrt[3]{x_0}$',xy=(1.912931,-0.01),xytext=(1.912931,-0.2),
               arrowprops=dict(arrowstyle="->"))
   ax.annotate(r'$x_{mid_2}$',xy=(2.625,0.01),xytext=(2.625,0.15),
               arrowprops=dict(arrowstyle="->"))
   ax.text(3.5,-0.1,r'$x_{mid_0}$')
   ax.text(7,-0.1,r'$x_0$')
   plt.axis('off')
   plt.draw()
   plt.savefig('numberAxis1.png')
   return 'numberAxis1.png'
   #+end_src

   #+RESULTS:
   [[file:numberAxis1.png]]
